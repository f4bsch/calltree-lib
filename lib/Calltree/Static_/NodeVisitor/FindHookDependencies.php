<?php
/**
 * Created by PhpStorm.
 * User: Fabian
 * Date: 07.10.2017
 * Time: 20:21
 */

namespace Calltree\Static_\NodeVisitor;

use Calltree\Static_\FunctionCollector;
use PhpParser\Node;
use PhpParser\NodeTraverser;


/**
 * Class FindHookDependencies
 *
 * This class tries to build a complete call graph, including the WordPress Hook API bus
 * It works with `add_{action|filter}('tag', X)`, where X can be like:
 *      `'N\func'`
 *      `['N\C', 'method']`
 *      `[__CLASS__, 'method']` (or `array(...)`)
 *      `[$this, 'method']` (resolved to class)
 *      `[$obj, 'method']` (here we don't resolve the `$obj` yet) TODO
 *      `function(...) {...}`
 *
 * Furthermore it detects function coupling, on both symbol (e.g. `func()`, self::m(), C::m(), new C; $this->f(), $other->f())
 * and - that's the tricky part - on callback (e.g. `array_map(X, [...])`) level.
 * Therefore it uses a prebuilt function declaration table, holding the parameter
 * that is (or might be) of type `callable`. This works with both internal (via Reflection)
 * and user functions/class methods. If no `callable` type hint is available, it uses the parameter
 * name to guess.
 *
 * Relevant WordPress Hook API Bus functions are:
 *      add_action($tag,...);
 *      add_filter($tag,...);
 *      do_action($tag,...);
 *      do_action_ref_array($tag,...);
 *      apply_filters($tag,...);
 *      apply_filters_ref_array($tag,...);
 *
 *
 * TODO
 * * func()->call()->call2();
 * * class C extends Cp {} o.O, "virtual" functions
 *
 * $func = function() {}
 *
 *
 * @package Calltree\Static_\NodeVisitor
 */
class FindHookDependencies extends BaseResolver {
	use HookNodeUtils;
	use CollectingUtils;
	use ResolvingUtils;
	use VariableDispenser;

	//use VariableCollector;

	public $functionsCallingFunctions = [];
	public $hooksCallingFunctions = [];
	public $functionsFiringHooks = [];
	public $hooksFiringHooks = [];

	public function serialize() {
		return [
			'funcFunc' => $this->functionsCallingFunctions,
			'funcHook' => $this->functionsFiringHooks,
			'hookFunc' => $this->hooksCallingFunctions,
			'hookHook' => $this->hooksFiringHooks
		];
	}


	/**
	 * We use this to resolve closure dependencies like:
	 * `add_action('tag1', function() { do_action('tag2'); });
	 * So tag2 fires whenever tag1 does
	 * @var Node[]
	 */
	private $addHookStack = [];

	/** @var Node */
	private $addHookStackTop = null;


	public function __construct( FunctionCollector $functionCollector ) {
		parent::__construct( $functionCollector );
	}


	public function beforeTraverse( array $nodes ) {
		parent::beforeTraverse( $nodes ); // TODO: Change the autogenerated stub
		$this->beforeTraverseVariableDispenser( $nodes );
	}

	public function enterNode( Node $node ) {
		parent::enterNode( $node );
		$this->enterNodeVariableDispenser( $node );

		if ( $node instanceof Node\FunctionLike && strpos( $node->getDocComment(), '@deprecated' ) !== false ) {
			return NodeTraverser::DONT_TRAVERSE_CHILDREN;
		}

		if ( ( $tag = $this->isAddHookCall( $node, $func ) ) ) {
			// we need this for adds with closures, e.g. add_action('tag', function() {...});
			$this->addHookStack[]  = $node;
			$this->addHookStackTop = $node;

			$func = $this->maybeAddClassName( $func, $node );

			$this->addToArrayMap( $this->hooksCallingFunctions, $tag, $func );
		} elseif ( $node instanceof Node\Expr\FuncCall && $node->name instanceof Node\Name ) {
			$calleeName = $node->name->toString();
			if ( ! $this->isDoHookName( $calleeName ) ) {
				$calleeName = $this->nameToString( $node->name ); // maybe add namespace


				if ( ! $this->functionCollector->isInternal( $calleeName ) ) {
					$this->addToArrayMap( $this->functionsCallingFunctions, $this->getCurrentFunctionLikeName(), $calleeName );
					//f($this->getCurrentFunctionLikeName() === 'bbp_body_class' ) {
					//print_r($this->functionsCallingFunctions);
					//echo "found bbp_body_class calling $calleeName in file $this->fileName";
					//exit;
					//}
				}
				//  functions can call functions through functions that accept callbacks:
				$this->maybeAddCallableCalleeParam( $node, $calleeName );
			}
		} else if ( ( $isStaticCall = ( $node instanceof Node\Expr\StaticCall ) ) ||
		            $node instanceof Node\Expr\MethodCall
		) {
			/** @noinspection PhpUndefinedFieldInspection */
			$calleeName = /* $this->maybeAddClassName*/
				( $this->bindAndFuncExprToFunctionName( $isStaticCall ? $node->class : $node->var, $node->name, true ) );
// wp_ajax_install_theme TODO WP_Error::get_error_*
			$this->addToArrayMap( $this->functionsCallingFunctions, $this->getCurrentFunctionLikeName(), $calleeName );

			// check if calling a function that accepts a function
			// TODO if calleeName is loose, this will always fail!
			$this->maybeAddCallableCalleeParam( $node, $calleeName );
		} else if ( $node instanceof Node\Expr\New_ ) {
			$this->resolveExpressionTypeVar( $node->class, $valClassName );
			$this->addToArrayMap( $this->functionsCallingFunctions, $this->getCurrentFunctionLikeName(), $valClassName . '::__construct' );
		}
	}

	public function maybeAddCallableCalleeParam( $node, $calleeName ) {

		// function_exists(), is_callable() do not actually call
		// TODO actually `function_exists()` will trigger class loaders, so there is a dependency, should be removed:
		if ( $this->functionCollector->isFunctionExists( $calleeName ) ) {
			return;
		}

		try {
			// check if calling a function that accepts a function
			$callableParam = $this->functionCollector->hasCallableParam( $calleeName );
			if ( $callableParam !== false && isset( $node->args[ $callableParam ] ) ) {
				$calleeName2 = $this->resolveFunctionNameFromExpression( $node->args[ $callableParam ]->value, $node );
				$this->addToArrayMap( $this->functionsCallingFunctions, $this->getCurrentFunctionLikeName(), $calleeName2 );
			}
		} catch ( \RuntimeException $e ) {
			$this->addWarning( $e );
		}
	}


	public function leaveNode( Node $node ) {
		if ( ( $firedTag = $this->isDoHookCall( $node ) ) ) {
			if ( $this->addHookStackTop ) {
				// TODO: remove this part, give closure names!! and treat them like non-anonymous funcs!
				// name should contain fileName and lineNumber
				// apparently we where firing a hook inside a closure
				// `add_hook(...,function() { do_action('tag2'); });`
				$firingTag = $this->isAddHookCall( $this->addHookStackTop );
				$this->addToArrayMap( $this->hooksFiringHooks, $firingTag, $firedTag );
			} elseif ( $this->functionLike ) {
				// function or method called `do_action()`
				$fullFunctionName = $this->fullFunctionName( $this->namespace, $this->classLike, $this->functionLike );
				if ( ! $firedTag || ( is_float( $firedTag ) && is_nan( $firedTag ) ) ) {
					$this->addWarning( $this->error( 'invalid firedTag', $node ) );
				} else {
					$this->addToArrayMap( $this->functionsFiringHooks, $fullFunctionName, $firedTag );
				}
			} else {
				// todo merge with last elseif()
				// global context
				if ( $this->classLike ) {
					throw new Error( "wtf, doHookCall outside FunctionLike but inside ClassLike", $node );
				}

				if ( ! $firedTag || ( is_float( $firedTag ) && is_nan( $firedTag ) ) ) {
					$this->addWarning( $this->error( 'invalid firedTag', $node ) );
				} else {
					$this->addToArrayMap( $this->functionsFiringHooks, self::CALLING_FROM_MAIN_CONTEXT, $firedTag );
				}
			}
		} elseif ( $node === $this->addHookStackTop ) {
			array_pop( $this->addHookStack );
			$this->addHookStackTop = end( $this->addHookStack );
		}

		$this->leaveNodeVariableDispenser( $node );
		parent::leaveNode( $node );
	}


	private function maybeAddClassName( $func, Node $context ) {
		if ( $func{0} == ':' ) {
			//if ( ! $this->classLike ) {
			throw $this->error( "maybeAddClassName with loose $func not in class context", $context );

			//}

			return $this->fullClassName( $this->namespace, $this->classLike ) . $func;
		} elseif ( $this->namespace ) {
			// already fullyClassified?
			if ( strpos( $func, '\\' ) !== false ) {
				return $func;
			}

			return $this->namespace->toString() . '\\' . $func;
		}

		// TODO what about add_action(..., ['RelNs\Class', 'staticMethod']) ????
		// i think the namespace must be absolute ...

		return $func;
	}

	private function resolveFunctionNameFromExpression( Node $expr, Node $context ) {
		return $this->maybeAddClassName( $this->exprToFunctionName( $expr ), $context );
	}
}